import React, { useState, useEffect, useRef, useContext, createContext, useCallback, useMemo } from 'react';
import ReactDOM from 'react-dom/client';
// FIX: Imported `Variants` type from framer-motion to resolve typing errors with animation variants.
import { motion, useInView, AnimatePresence, Variants, Reorder } from 'framer-motion';
import { marked } from 'marked';
import { GoogleGenAI, GenerateContentResponse, Type } from '@google/genai';

// --- THEME COLORS (mirroring CSS variables) ---
const darkThemeColors = {
    bgColor: '#0d1117',
    cardColor: '#161b22',
    borderColor: '#30363d',
    textPrimary: '#c9d1d9',
    textSecondary: '#8b949e',
    accentPrimary: '#58a6ff',
    accentSecondary: '#f1e05a',
    accentTeal: '#39d39f',
    accentDanger: '#f85149',
    accentOrange: '#EE9B00',
    colorSpread: ['#58a6ff', '#39d39f', '#f1e05a', '#f85149', '#e987f1', '#79c0ff']
};

const lightThemeColors = {
    bgColor: '#f6f8fa',
    cardColor: '#ffffff',
    borderColor: '#d0d7de',
    textPrimary: '#24292f',
    textSecondary: '#57606a',
    accentPrimary: '#0969da',
    accentSecondary: '#bf8700',
    accentTeal: '#1a7f64',
    accentDanger: '#d73a49',
    accentOrange: '#f58518',
    colorSpread: ['#0969da', '#1a7f64', '#bf8700', '#d73a49', '#c262c7', '#218bff']
};

// --- REFRESH CONTEXT ---
const RefreshContext = createContext({
    refreshAll: async () => {},
    register: (id, fetcher) => {},
    unregister: (id) => {},
    isRefreshing: false,
});

const useRefresh = () => useContext(RefreshContext);

const RefreshProvider = ({ children }) => {
    const [isRefreshing, setIsRefreshing] = useState(false);
    const fetchersRef = useRef(new Map());

    const register = useCallback((id, fetcher) => {
        fetchersRef.current.set(id, fetcher);
    }, []);

    const unregister = useCallback((id) => {
        fetchersRef.current.delete(id);
    }, []);

    const refreshAll = useCallback(async () => {
        if (isRefreshing) return;
        setIsRefreshing(true);
        const promises = [];
        fetchersRef.current.forEach(fetcher => {
            promises.push(fetcher());
        });
        await Promise.allSettled(promises);
        // Add a small delay for the animation to feel complete
        setTimeout(() => setIsRefreshing(false), 500);
    }, [isRefreshing]);

    const value = { refreshAll, register, unregister, isRefreshing };

    // FIX: Corrected a typo in the closing tag for RefreshContext.Provider.
    return <RefreshContext.Provider value={value}>{children}</RefreshContext.Provider>;
};


// --- THEME CONTEXT ---
const ThemeContext = createContext({
  theme: 'dark',
  toggleTheme: () => {},
});

const useTheme = () => useContext(ThemeContext);

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState(() => {
    try {
        const storedTheme = localStorage.getItem('theme');
        return storedTheme || 'dark';
    } catch (error) {
        console.warn("Could not access localStorage. Defaulting to dark theme.");
        return 'dark';
    }
  });

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    try {
        localStorage.setItem('theme', theme);
    } catch (error) {
        console.warn("Could not write to localStorage.");
    }
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// --- ANIMATION VARIANTS ---
// FIX: Explicitly typed `listVariants` with the `Variants` type for better type safety.
const listVariants: Variants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.07,
            delayChildren: 0.2,
        },
    },
};

// FIX: Explicitly typed `listItemVariants` with the `Variants` type to correct an issue where the `ease` property was being inferred as a generic string, causing a type error.
const listItemVariants: Variants = {
    hidden: { opacity: 0, y: 10 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            duration: 0.4,
            ease: 'easeOut'
        }
    },
};

const contentVariants: Variants = {
    hidden: { opacity: 0, y: 10 },
    visible: { opacity: 1, y: 0, transition: { duration: 0.4, ease: "easeOut" } },
    exit: { opacity: 0, scale: 0.95, transition: { duration: 0.2, ease: "easeIn" } }
};

const weatherContentVariants: Variants = {
    hidden: { opacity: 0, scale: 0.8 },
    visible: {
        opacity: 1,
        scale: 1,
        transition: {
            type: "spring",
            stiffness: 350,
            damping: 25
        }
    },
    exit: { opacity: 0, scale: 0.8, transition: { duration: 0.2, ease: "easeIn" } }
};

const popoverVariants: Variants = {
    hidden: { opacity: 0, scale: 0.95, y: -10, originY: '0%' },
    visible: { opacity: 1, scale: 1, y: 0, transition: { duration: 0.2, ease: "easeOut" } },
    exit: { opacity: 0, scale: 0.95, y: -10, transition: { duration: 0.15, ease: "easeIn" } }
};


// --- API HELPER ---
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
const model = 'gemini-2.5-flash';
const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

async function generateContent(request) {
    try {
        const response = await ai.models.generateContent({
            model,
            ...request,
        });
        return response;
    } catch (error) {
        console.error("Gemini API call failed:", error);
        throw error;
    }
}

// --- HOOKS ---
const useLocalStorage = (key, initialValue) => {
    const [storedValue, setStoredValue] = useState(() => {
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        } catch (error) {
            console.warn(`Error reading localStorage key “${key}”:`, error);
            return initialValue;
        }
    });

    const setValue = (value) => {
        try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
            console.warn(`Error setting localStorage key “${key}”:`, error);
        }
    };

    return [storedValue, setValue];
};

const useClickOutside = (ref, handler) => {
    useEffect(() => {
        const listener = (event) => {
            if (!ref.current || ref.current.contains(event.target as Node)) {
                return;
            }
            handler(event);
        };
        document.addEventListener('mousedown', listener);
        document.addEventListener('touchstart', listener);
        return () => {
            document.removeEventListener('mousedown', listener);
            document.removeEventListener('touchstart', listener);
        };
    }, [ref, handler]);
};

const useGemini = (request, { autoFetch = true, initialDelay = 0 } = {}) => {
    const [data, setData] = useState<GenerateContentResponse | null>(null);
    const [isLoading, setIsLoading] = useState(autoFetch);
    const [error, setError] = useState<string | null>(null);

    const requestRef = useRef(request);
    useEffect(() => {
        requestRef.current = request;
    }, [JSON.stringify(request)]);

    const isMounted = useRef(true);
    useEffect(() => {
        isMounted.current = true;
        return () => { isMounted.current = false; };
    }, []);

    const fetchData = useCallback(async () => {
        if (!isMounted.current) return;
        setIsLoading(true);
        setError(null);

        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await generateContent(requestRef.current);
                if (isMounted.current) {
                    setData(response);
                    setIsLoading(false);
                    return; // Success
                }
            } catch (e: any) {
                const errorMessage = e.message || 'An unexpected error occurred.';
                const isRateLimitError = errorMessage.includes('429') || errorMessage.includes('RESOURCE_EXHAUSTED');
                
                if (isRateLimitError && attempt < maxRetries - 1) {
                    const backoffTime = Math.pow(2, attempt + 1) * 1000 + Math.random() * 1000;
                    console.warn(`Rate limit exceeded. Retrying attempt ${attempt + 2}/${maxRetries} in ${Math.round(backoffTime / 1000)}s...`);
                    await delay(backoffTime);
                } else {
                    if (isMounted.current) {
                        const finalError = isRateLimitError 
                            ? 'The service is currently busy. Please try again in a moment.' 
                            : 'Failed to get a response from the AI. Please check the console for details.';
                        setError(finalError);
                        setIsLoading(false);
                    }
                    return;
                }
            }
        }
    }, []);

    useEffect(() => {
        if (autoFetch) {
            const timerId = setTimeout(fetchData, initialDelay);
            return () => clearTimeout(timerId);
        }
    }, [fetchData, autoFetch, initialDelay]);

    return { data, isLoading, error, fetchData };
};


// --- UI COMPONENTS ---
const TextToSpeechButton = ({ textToSpeak, playAriaLabel = "Explain this", stopAriaLabel = "Stop explanation" }) => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const [voice, setVoice] = useState(null);

    useEffect(() => {
        if (!('speechSynthesis' in window)) {
            console.warn("Speech Synthesis not supported by this browser.");
            setIsSupported(false);
            return;
        }
        setIsSupported(true);

        const loadVoices = () => {
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice =
                voices.find(v => v.name.includes('Google') && v.lang.startsWith('en-US')) ||
                voices.find(v => v.lang.startsWith('en-US')) ||
                voices.find(v => v.lang.startsWith('en'));
            if (preferredVoice) {
                setVoice(preferredVoice);
            }
        };

        loadVoices();
        if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = loadVoices;
        }

        return () => {
            if (window.speechSynthesis) {
                window.speechSynthesis.onvoiceschanged = null;
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
            }
        };
    }, []);

    const handleToggleAudio = () => {
        if (!isSupported || !textToSpeak) return;

        if (isSpeaking) {
            window.speechSynthesis.cancel();
        } else {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            if (voice) {
                utterance.voice = voice;
            }
            utterance.onstart = () => setIsSpeaking(true);
            utterance.onend = () => setIsSpeaking(false);
            utterance.onerror = (event) => {
                if (event.error !== 'interrupted' && event.error !== 'canceled') {
                    console.error("Speech synthesis error:", event.error);
                }
                setIsSpeaking(false);
            };
            window.speechSynthesis.speak(utterance);
        }
    };

    if (!isSupported || !textToSpeak || !voice) {
        return null;
    }

    return (
        <motion.button
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            onClick={handleToggleAudio}
            className="p-2 rounded-full hover:bg-[var(--border-color)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-[var(--text-secondary)] hover:text-[var(--text-primary)]"
            aria-label={isSpeaking ? stopAriaLabel : playAriaLabel}
            title={isSpeaking ? stopAriaLabel : playAriaLabel}
        >
            <AnimatePresence mode="wait" initial={false}>
                <motion.div
                    key={isSpeaking ? "stop" : "play"}
                    initial={{ opacity: 0, scale: 0.5 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.5 }}
                    transition={{ duration: 0.15 }}
                    style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}
                >
                    {isSpeaking ? (
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h12v12H6z"/></svg>
                    ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                    )}
                </motion.div>
            </AnimatePresence>
        </motion.button>
    );
};


const Loader = ({ small = false }) => (
    <div 
        className={`loader ${small ? 'small' : ''}`}
        aria-label="Loading content"
        role="status"
    />
);


const SkeletonElement = ({ className = '' }) => <div className={`skeleton-element rounded-md ${className}`} />;

const WidgetSkeleton = ({ type }: { type: string }) => {
    switch (type) {
        case 'news':
            return (
                <div className="w-full h-full flex flex-col gap-4 p-1">
                    <SkeletonElement className="aspect-video rounded-lg" />
                    <div className="flex justify-between items-center">
                        <SkeletonElement className="h-8 w-1/2" />
                        <SkeletonElement className="h-8 w-8 rounded-full" />
                    </div>
                    <div className="flex gap-2">
                        <SkeletonElement className="h-6 w-20 rounded-full" />
                        <SkeletonElement className="h-6 w-24 rounded-full" />
                        <SkeletonElement className="h-6 w-20 rounded-full" />
                    </div>
                    <div className="space-y-2 mt-2">
                        <SkeletonElement className="h-4 w-full" />
                        <SkeletonElement className="h-4 w-full" />
                        <SkeletonElement className="h-4 w-3/4" />
                    </div>
                </div>
            );
        case 'weather':
            return (
                 <div className="w-full h-full flex flex-col items-center justify-center gap-4">
                    <SkeletonElement className="h-20 w-20 rounded-full" />
                    <SkeletonElement className="h-10 w-32" />
                    <SkeletonElement className="h-6 w-24" />
                </div>
            );
        case 'market':
            return (
                <div className="w-full h-full flex flex-col justify-center gap-4 p-1">
                    <div className="flex justify-between"><SkeletonElement className="h-5 w-1/3" /><SkeletonElement className="h-5 w-1/4" /></div>
                    <div className="flex justify-between"><SkeletonElement className="h-5 w-1/3" /><SkeletonElement className="h-5 w-1/4" /></div>
                    <div className="flex justify-between"><SkeletonElement className="h-5 w-1/3" /><SkeletonElement className="h-5 w-1/4" /></div>
                    <SkeletonElement className="h-4 w-full mt-2" />
                </div>
            );
        case 'events':
            return (
                <div className="w-full h-full flex flex-col justify-center gap-4 p-1">
                    {[...Array(4)].map((_, i) => (
                        <div key={i} className="flex items-center gap-4">
                            <SkeletonElement className="h-16 w-16 rounded-lg flex-shrink-0" />
                            <SkeletonElement className="h-6 w-full" />
                        </div>
                    ))}
                </div>
            );
        case 'joke':
            return (
                <div className="w-full h-full flex flex-col items-center justify-center gap-3 p-1">
                    <SkeletonElement className="h-5 w-5/6" />
                    <SkeletonElement className="h-5 w-full" />
                    <SkeletonElement className="h-5 w-3/4" />
                </div>
            );
        default:
            return <div className="flex-grow flex items-center justify-center"><Loader /></div>;
    }
};


const ErrorDisplay = ({ message, onRetry, className = '' }) => (
    <div className={`text-center p-4 bg-red-900/50 text-red-300 border border-red-500/50 rounded-lg ${className}`}>
        <p className="mb-3">{message}</p>
        <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={onRetry}
            className="btn btn-primary"
        >
            Retry
        </motion.button>
    </div>
);

const WidgetProgressBar = () => (
    <motion.div
        className="widget-progress-bar"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.2 }}
    />
);

const AnimatedCard = ({ children, className = '', isRefreshing = false }: { children?: React.ReactNode; className?: string; isRefreshing?: boolean; }) => {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.1 });

    return (
        <motion.div
            ref={ref}
            initial={{ opacity: 0, y: 25 }}
            animate={isInView ? { opacity: 1, y: 0 } : {}}
            transition={{ duration: 0.5, ease: [0.25, 0.1, 0.25, 1.0] }}
            className={`relative bg-[var(--card-color)] border border-[var(--border-color)] rounded-xl shadow-2xl shadow-black/25 transition-colors duration-300 interactive-card h-full flex flex-col overflow-hidden ${className}`}
        >
             <div className="drag-indicator" aria-hidden="true">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
                    <circle cx="9" cy="12" r="1"></circle>
                    <circle cx="9" cy="5" r="1"></circle>
                    <circle cx="9" cy="19" r="1"></circle>
                    <circle cx="15" cy="12" r="1"></circle>
                    <circle cx="15" cy="5" r="1"></circle>
                    <circle cx="15" cy="19" r="1"></circle>
                </svg>
            </div>
            <AnimatePresence>
                {isRefreshing && <WidgetProgressBar />}
            </AnimatePresence>
            <div className="p-6 md:p-8 h-full flex flex-col flex-grow">
                {children}
            </div>
        </motion.div>
    );
};

const ThemeToggle = () => {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="theme-toggle"
            aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
            title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
            aria-pressed={theme === 'dark'}
        >
            <div className="theme-toggle-track">
                <div className="theme-toggle-thumb">
                    {theme === 'light' ? (
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41L5.64 5.64zm12.72 12.72c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.41 1.41c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41l-1.41-1.41zM5.64 18.36l-1.41-1.41c-.39-.39-.39-1.02 0-1.41s1.02-.39 1.41 0l1.41 1.41c.39.39.39 1.02 0 1.41s-1.02.39-1.41 0zm12.72-12.72l-1.41-1.41c-.39-.39-.39-1.02 0-1.41s1.02-.39 1.41 0l1.41 1.41c.39.39.39 1.02 0 1.41s-1.02.39-1.41 0z"/></svg>
                    ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M9.37 5.51c.46-2.25 2.98-3.3 4.63-2.02.34.26.54.68.54 1.12v.17c0 .44.24.84.62 1.04.83.43 1.5 1.14 1.88 2 .38.86.5 1.83.33 2.78-.22 1.22-.89 2.24-1.84 2.96-1.34.99-2.92 1.43-4.54 1.25-2.41-.28-4.42-2-5.32-4.29-.46-1.15-.55-2.42-.25-3.62.29-1.15.99-2.12 1.95-2.78.47-.32.99-.54 1.54-.64z"/></svg>
                    )}
                </div>
            </div>
        </button>
    );
};

const Header = () => {
    const { refreshAll, isRefreshing } = useRefresh();
    return (
        <header className="relative text-left mb-12 flex justify-between items-center gap-4">
            <motion.div 
                className="flex items-center gap-4"
                initial="hidden"
                animate="visible"
                variants={{
                    visible: { transition: { staggerChildren: 0.15 } }
                }}
            >
                <motion.div variants={listItemVariants}>
                    <div className="header-logo">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg>
                    </div>
                </motion.div>
                 <motion.div variants={listItemVariants}>
                    <h1 className="text-3xl md:text-4xl font-black text-[var(--text-primary)] tracking-tighter">SKOVIE</h1>
                </motion.div>
            </motion.div>
            <motion.div 
                className="flex items-center gap-3"
                initial="hidden"
                animate="visible"
                 variants={{
                    visible: { transition: { staggerChildren: 0.15, delayChildren: 0.3 } }
                }}
            >
                <motion.div variants={listItemVariants}>
                     <button
                        onClick={refreshAll}
                        disabled={isRefreshing}
                        className="p-2 rounded-full text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--border-color)] transition-colors disabled:opacity-50 disabled:cursor-wait"
                        aria-label="Refresh all widgets"
                        title="Refresh all widgets"
                    >
                        <motion.svg
                            animate={{ rotate: isRefreshing ? 360 : 0 }}
                            transition={{ duration: 1, repeat: isRefreshing ? Infinity : 0, ease: 'linear' }}
                            xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
                        >
                            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/>
                        </motion.svg>
                    </button>
                </motion.div>
                <motion.div variants={listItemVariants}>
                    <ThemeToggle />
                </motion.div>
            </motion.div>
        </header>
    );
};

// FIX: Added explicit prop types to make the `children` prop optional, resolving a type error.
const WidgetHeader = ({ title, icon, children }: { title: string, icon: React.ReactNode, children?: React.ReactNode }) => (
    <div className="flex justify-between items-center mb-4">
        <div className="card-header">
            {icon}
            <h2 className="flex-1 min-w-0 truncate">{title}</h2>
        </div>
        {children && <div className="flex items-center gap-2">{children}</div>}
    </div>
);


const SourcesList = ({ sources, className = '' }) => {
    if (!sources || sources.length === 0) return null;

    const getFaviconUrl = (url) => {
        try {
            const { hostname } = new URL(url);
            return `https://www.google.com/s2/favicons?domain=${hostname}&sz=32`;
        } catch (error) {
            console.error("Invalid URL for favicon:", url);
            return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Transparent pixel
        }
    };

    return (
        <motion.ul variants={listVariants} initial="hidden" animate="visible" className={`mt-4 space-y-2 ${className}`}>
            {sources.map((source, index) => (
                <motion.li key={index} variants={listItemVariants} className="sources-list-item">
                    <a href={source.web.uri} target="_blank" rel="noopener noreferrer" className="source-link" title={source.web.title || source.web.uri}>
                        <img src={getFaviconUrl(source.web.uri)} alt="" className="w-4 h-4 rounded-full" aria-hidden="true" />
                        <span>{source.web.title || source.web.uri}</span>
                    </a>
                </motion.li>
            ))}
        </motion.ul>
    );
};


// --- WIDGETS ---

const NewsWidget = ({ widgetId }) => {
    const [topic, setTopic] = useState('technology');
    const { isRefreshing, register, unregister } = useRefresh();
    
    const topics = useMemo(() => ['technology', 'world', 'business', 'science', 'sports'], []);
    
    const request = useMemo(() => ({
        contents: `Summarize the top 3 latest ${topic} news headlines. For each, provide a very brief 1-2 sentence summary. Include web sources.`,
        config: {
            tools: [{ googleSearch: {} }]
        },
    }), [topic]);

    const { data, isLoading, error, fetchData } = useGemini(request);

    useEffect(() => {
        register(widgetId, fetchData);
        return () => unregister(widgetId);
    }, [widgetId, fetchData, register, unregister]);

    const handleTopicChange = useCallback((newTopic) => {
        setTopic(newTopic);
    }, []);

    const content = data?.text || '';
    const sources = data?.candidates?.[0]?.groundingMetadata?.groundingChunks || [];
    const summaryExplanation = `This is an AI-generated summary of the top news in ${topic}. The information is grounded in Google Search results, and the sources are listed below.`;

    const parsedContent = useMemo(() => {
        try {
            return marked.parse(content);
        } catch (e) {
            console.error("Markdown parsing failed:", e);
            return `<p>${content.replace(/\n/g, '<br>')}</p>`;
        }
    }, [content]);

    return (
        <AnimatedCard isRefreshing={isRefreshing}>
            <WidgetHeader
                title="Top News"
                icon={<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>}
            >
                <TextToSpeechButton textToSpeak={summaryExplanation} playAriaLabel="Explain this news summary" />
            </WidgetHeader>
             <div className="flex gap-2 flex-wrap mb-4">
                {topics.map(t => (
                    <button
                        key={t}
                        onClick={() => handleTopicChange(t)}
                        className={`btn-tag ${topic === t ? 'active' : ''}`}
                        disabled={isLoading}
                        aria-pressed={topic === t}
                    >
                        {t.charAt(0).toUpperCase() + t.slice(1)}
                    </button>
                ))}
            </div>

            <AnimatePresence mode="wait">
                {isLoading && !data ? (
                     <motion.div key="skeleton" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                        <WidgetSkeleton type="news" />
                    </motion.div>
                ) : error ? (
                    <motion.div key="error" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                         <ErrorDisplay message={error} onRetry={fetchData} />
                    </motion.div>
                ) : (
                    <motion.div key="content" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                        <div
                            className="prose prose-sm max-w-none flex-grow"
                            dangerouslySetInnerHTML={{ __html: parsedContent }}
                        />
                        <SourcesList sources={sources} />
                    </motion.div>
                )}
            </AnimatePresence>
        </AnimatedCard>
    );
};

// FIX: Refactored to handle JSON parsing errors locally instead of relying on a non-existent `setError` function.
const MarketWidget = ({ widgetId }) => {
    const [stocks, setStocks] = useLocalStorage('market_stocks_v1', ['MSFT', 'GOOGL', 'TSLA']);
    const [period, setPeriod] = useState('1D');
    const { isRefreshing, register, unregister } = useRefresh();
    const periods = useMemo(() => ['1D', '5D', '1M', '6M', '1Y'], []);
    const [parsingError, setParsingError] = useState<string | null>(null);

    const request = useMemo(() => ({
        contents: `Get the latest stock market data for these symbols: ${stocks.join(', ')}. Include the current price, the change amount, and the change percentage for the ${period} period.`,
        config: {
            responseMimeType: 'application/json',
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        symbol: { type: Type.STRING },
                        price: { type: Type.STRING },
                        change: { type: Type.STRING },
                        percent_change: { type: Type.STRING }
                    }
                }
            }
        }
    }), [stocks, period]);

    const { data, isLoading, error: apiError, fetchData } = useGemini(request, { initialDelay: 500 });
    const [marketData, setMarketData] = useState(null);

    useEffect(() => {
        register(widgetId, fetchData);
        return () => unregister(widgetId);
    }, [widgetId, fetchData, register, unregister]);

    useEffect(() => {
        if (!data?.text) {
            setMarketData(null);
            return;
        }
        try {
            setMarketData(JSON.parse(data.text));
            setParsingError(null);
        } catch (e) {
            console.error("Failed to parse market data JSON:", e);
            setParsingError("The AI returned data in an unexpected format.");
            setMarketData(null);
        }
    }, [data]);

    const overallTrend = useMemo(() => {
        if (!marketData || marketData.length === 0) return 'neutral';
        const positive = marketData.filter(s => parseFloat(s.change) >= 0).length;
        const negative = marketData.length - positive;
        if (positive > negative) return 'positive';
        if (negative > positive) return 'negative';
        return 'neutral';
    }, [marketData]);

    const cardTrendClass = {
        'positive': 'market-positive-trend',
        'negative': 'market-negative-trend',
        'neutral': ''
    }[overallTrend];

    const marketSummary = `Here's the market summary for ${stocks.join(', ')}. The overall trend is currently ${overallTrend}.`;
    const error = apiError || parsingError;

    return (
        <AnimatedCard className={cardTrendClass} isRefreshing={isRefreshing}>
             <WidgetHeader
                title="Market Watch"
                icon={<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>}
             >
                <TextToSpeechButton textToSpeak={marketSummary} playAriaLabel="Explain market summary" />
             </WidgetHeader>
             <div className="flex gap-2 flex-wrap mb-4">
                {periods.map(p => (
                    <button
                        key={p}
                        onClick={() => setPeriod(p)}
                        className={`btn-tag ${period === p ? 'active' : ''}`}
                        disabled={isLoading}
                        aria-pressed={period === p}
                    >
                        {p}
                    </button>
                ))}
            </div>

            <div className="flex-grow flex flex-col justify-center">
                <AnimatePresence mode="wait">
                    {isLoading && !marketData ? (
                        <motion.div key="skeleton" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                            <WidgetSkeleton type="market" />
                        </motion.div>
                    ) : error ? (
                        <motion.div key="error" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                            <ErrorDisplay message={error} onRetry={fetchData} />
                        </motion.div>
                    ) : (
                        <motion.div key="content" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                            {marketData && marketData.length > 0 ? (
                                <motion.ul variants={listVariants} className="space-y-3">
                                    {marketData.map(stock => {
                                        const isPositive = parseFloat(stock.change) >= 0;
                                        return (
                                            <motion.li key={stock.symbol} variants={listItemVariants} className="flex justify-between items-baseline">
                                                <span className="font-bold text-lg text-[var(--text-primary)]">{stock.symbol}</span>
                                                <div className="text-right">
                                                    <span className="font-semibold text-[var(--text-primary)] block">{stock.price}</span>
                                                    <span className={`${isPositive ? 'text-positive' : 'text-negative'}`}>
                                                        {isPositive ? '+' : ''}{stock.change} ({isPositive ? '+' : ''}{stock.percent_change})
                                                    </span>
                                                </div>
                                            </motion.li>
                                        );
                                    })}
                                </motion.ul>
                            ) : (
                                <p className="text-center text-[var(--text-secondary)]">No market data available.</p>
                            )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </AnimatedCard>
    );
};

// FIX: Refactored to handle JSON parsing errors locally instead of relying on a non-existent `setError` function.
const EventsWidget = ({ widgetId }) => {
    const { isRefreshing, register, unregister } = useRefresh();
    const request = useMemo(() => ({
        contents: "List the next 4 upcoming major global holidays or notable events. Provide the name, emoji, and date.",
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: {
                        name: { type: Type.STRING },
                        emoji: { type: Type.STRING },
                        date: { type: Type.STRING, description: "Use YYYY-MM-DD format" },
                    },
                },
            },
        },
    }), []);

    const { data, isLoading, error: apiError, fetchData } = useGemini(request, { initialDelay: 1000 });
    const [eventsData, setEventsData] = useState(null);
    const [parsingError, setParsingError] = useState<string | null>(null);

    useEffect(() => {
        register(widgetId, fetchData);
        return () => unregister(widgetId);
    }, [widgetId, fetchData, register, unregister]);

    useEffect(() => {
        if (!data?.text) {
            setEventsData(null);
            return;
        }
        try {
            setEventsData(JSON.parse(data.text));
            setParsingError(null);
        } catch (e) {
            console.error("Failed to parse events data JSON:", e);
            setParsingError("AI returned event data in an unexpected format.");
            setEventsData(null);
        }
    }, [data]);
    
    const formatDate = (dateString) => {
        try {
            const date = new Date(dateString + 'T00:00:00'); // Assume UTC to avoid timezone issues
            return {
                month: date.toLocaleString('default', { month: 'short' }).toUpperCase(),
                day: date.getDate(),
            };
        } catch (e) {
            return { month: 'ERR', day: '!' };
        }
    };

    const error = apiError || parsingError;

    return (
        <AnimatedCard isRefreshing={isRefreshing}>
            <WidgetHeader
                title="Upcoming Events"
                icon={<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>}
            />
             <div className="flex-grow flex flex-col justify-center">
                <AnimatePresence mode="wait">
                    {isLoading && !eventsData ? (
                        <motion.div key="skeleton" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                            <WidgetSkeleton type="events" />
                        </motion.div>
                    ) : error ? (
                        <motion.div key="error" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                             <ErrorDisplay message={error} onRetry={fetchData} />
                        </motion.div>
                    ) : (
                        <motion.div key="content" variants={contentVariants} initial="hidden" animate="visible" exit="exit" className="events-list-container">
                             {eventsData && eventsData.length > 0 ? (
                                <motion.ul variants={listVariants} className="space-y-4">
                                    {eventsData.map((event, index) => {
                                        const { month, day } = formatDate(event.date);
                                        return (
                                            <motion.li key={`${event.name}-${index}`} variants={listItemVariants} className="event-item">
                                                <div className="event-date">
                                                    <span className="event-date-month">{month}</span>
                                                    <span className="event-date-day">{day}</span>
                                                </div>
                                                <div className="event-details">
                                                    <span className="event-emoji" aria-hidden="true">{event.emoji}</span>
                                                    <span className="event-name" title={event.name}>{event.name}</span>
                                                </div>
                                            </motion.li>
                                        );
                                    })}
                                </motion.ul>
                             ) : (
                                <p className="text-center text-[var(--text-secondary)]">No upcoming events found.</p>
                             )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </AnimatedCard>
    );
};

// FIX: Refactored to handle JSON parsing errors locally instead of relying on a non-existent `setError` function.
const JokeWidget = ({ widgetId }) => {
    const [category, setCategory] = useState('any');
    const { isRefreshing, register, unregister } = useRefresh();
    const categories = useMemo(() => ['any', 'programming', 'puns'], []);

    const request = useMemo(() => ({
        contents: `Tell me a short, SFW (safe for work) ${category === 'any' ? '' : category} joke.`,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    setup: { type: Type.STRING },
                    punchline: { type: Type.STRING }
                }
            }
        }
    }), [category]);

    const { data, isLoading, error: apiError, fetchData } = useGemini(request, { initialDelay: 1500 });
    const [jokeData, setJokeData] = useState(null);
    const [parsingError, setParsingError] = useState<string | null>(null);

    useEffect(() => {
        register(widgetId, fetchData);
        return () => unregister(widgetId);
    }, [widgetId, fetchData, register, unregister]);

    useEffect(() => {
        if (!data?.text) {
            setJokeData(null);
            return;
        }
        try {
            setJokeData(JSON.parse(data.text));
            setParsingError(null);
        } catch (e) {
            console.error("Failed to parse joke JSON:", e);
            setParsingError("The AI told a joke so good, it broke the app.");
            setJokeData(null);
        }
    }, [data]);

    const handleNewJoke = useCallback(() => {
        fetchData();
    }, [fetchData]);
    
    const jokeText = jokeData ? `${jokeData.setup} ${jokeData.punchline}` : "Sorry, I couldn't think of a joke right now.";
    const error = apiError || parsingError;

    return (
        <AnimatedCard isRefreshing={isRefreshing}>
             <WidgetHeader
                title="Daily Chuckle"
                icon={<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>}
             >
                <TextToSpeechButton textToSpeak={jokeText} playAriaLabel="Tell me the joke" />
             </WidgetHeader>
            <div className="flex-grow flex flex-col justify-center items-center text-center gap-6">
                <AnimatePresence mode="wait">
                    {isLoading && !jokeData ? (
                        <motion.div key="skeleton" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                            <WidgetSkeleton type="joke" />
                        </motion.div>
                    ) : error ? (
                        <motion.div key="error" variants={contentVariants} initial="hidden" animate="visible" exit="exit">
                           <ErrorDisplay message={error} onRetry={handleNewJoke} />
                        </motion.div>
                    ) : (
                        <motion.div key={jokeData?.setup} variants={contentVariants} initial="hidden" animate="visible" exit="exit" className="w-full">
                            {jokeData ? (
                                <>
                                    <p className="text-lg text-[var(--text-secondary)]">{jokeData.setup}</p>
                                    <p className="text-xl font-bold text-[var(--text-primary)] mt-2">{jokeData.punchline}</p>
                                </>
                            ) : (
                                <p className="text-[var(--text-secondary)]">Could not fetch a joke.</p>
                            )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ delay: 0.3 }}>
                <button onClick={handleNewJoke} disabled={isLoading} className="btn btn-secondary w-full mt-6">
                    {isLoading ? <Loader small /> : 'Another!'}
                </button>
            </motion.div>
        </AnimatedCard>
    );
};

const WeatherIcon = ({ iconName, className = '' }) => {
    const icons = {
        'sunny': (
             <motion.svg initial={{ scale: 0.5, opacity: 0, rotate: -90 }} animate={{ scale: 1, opacity: 1, rotate: 0 }} transition={{ type: 'spring', stiffness: 200, damping: 15 }} viewBox="0 0 64 64" className={className}><g><circle cx="32" cy="32" r="17" fill="#f1e05a"/><path d="M32 10.4V4M32 60v-6.4M43.6 20.4l4.5-4.5M15.9 52.6l4.5-4.5M20.4 20.4l-4.5-4.5M48.1 52.6l-4.5-4.5M53.6 32H60M4 32h6.4" fill="none" stroke="#f1e05a" stroke-linecap="round" stroke-miterlimit="10" stroke-width="4"/></g></motion.svg>
        ),
        'partly-cloudy': (
            <motion.svg initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }} viewBox="0 0 64 64" className={className}><path fill="#f1e05a" d="M43.6,31.2c2,0,3.9,0.3,5.6,0.9c0.5-2.1,0.8-4.3,0.8-6.6c0-10.5-8.5-19-19-19c-8.9,0-16.4,6.1-18.4,14.4c-0.4-0.1-0.9-0.1-1.3-0.1c-6.1,0-11,4.9-11,11s4.9,11,11,11h34c4.4,0,8-3.6,8-8C51.6,34.4,48,31.2,43.6,31.2z" stroke="#c9d1d9" stroke-width="2" stroke-linejoin="round" stroke-miterlimit="10"/><path fill="#c9d1d9" d="M45,51H11c-6.1,0-11-4.9-11-11s4.9-11,11-11c0.5,0,1,0,1.4,0.1C14.7,21.6,22.5,16,31.5,16c9.9,0,18,7.6,18.4,17.4c0.1,0,0.1,0,0.2,0c4.4,0,8,3.6,8,8S49.4,51,45,51z" stroke="#c9d1d9" stroke-width="2" stroke-linejoin="round" stroke-miterlimit="10"/></motion.svg>
        ),
        'cloudy': (
            <motion.svg initial={{ opacity: 0, scale: 0.7 }} animate={{ opacity: 1, scale: 1 }} transition={{ duration: 0.4 }} viewBox="0 0 64 64" className={className}><path d="M45 51H11c-6.1 0-11-4.9-11-11s4.9-11 11-11c.5 0 1 0 1.4.1C14.7 21.6 22.5 16 31.5 16c9.9 0 18 7.6 18.4 17.4.1 0 .1 0 .2 0c4.4 0 8 3.6 8 8s-4.4 8-8 8z" fill="#8b949e" stroke="#8b949e" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/></motion.svg>
        ),
        'rain': (
             <motion.svg initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ delay: 0.2 }} viewBox="0 0 64 64" className={className}><g><path d="M45 51H11c-6.1 0-11-4.9-11-11s4.9-11 11-11c.5 0 1 0 1.4.1C14.7 21.6 22.5 16 31.5 16c9.9 0 18 7.6 18.4 17.4.1 0 .1 0 .2 0c4.4 0 8 3.6 8 8s-4.4 8-8 8z" fill="#8b949e" stroke="#8b949e" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/></g><motion.g initial="hidden" animate="visible" variants={{ visible: { transition: { staggerChildren: 0.2 } } }}>{[...Array(3)].map((_, i) => <motion.path key={i} variants={{ hidden: { y: -10, opacity: 0 }, visible: { y: 0, opacity: 1, transition: { repeat: Infinity, duration: 1.5, delay: i * 0.3 } } }} d={`M20 ${56+i*2} l-3 5 M32 ${56+i*2} l-3 5 M44 ${56+i*2} l-3 5`} fill="none" stroke="#58a6ff" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>)}</motion.g></motion.svg>
        ),
        'thunderstorm': (
            <motion.svg viewBox="0 0 64 64" className={className}><g><path d="M45,51H11c-6.1,0-11-4.9-11-11s4.9-11,11-11c0.5,0,1,0,1.4,0.1C14.7,21.6,22.5,16,31.5,16c9.9,0,18,7.6,18.4,17.4c0.1,0,0.1,0,0.2,0c4.4,0,8,3.6,8,8S49.4,51,45,51z" fill="#8b949e" stroke="#8b949e" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/><motion.polygon animate={{ opacity: [0, 1, 0] }} transition={{ repeat: Infinity, duration: 1.5 }} points="32,49 23,59 34,59 25,69" fill="#f1e05a" stroke="#f1e05a" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/></g></motion.svg>
        ),
        'snow': (
             <motion.svg viewBox="0 0 64 64" className={className}><g><path d="M45 51H11c-6.1 0-11-4.9-11-11s4.9-11 11-11c.5 0 1 0 1.4.1C14.7 21.6 22.5 16 31.5 16c9.9 0 18 7.6 18.4 17.4.1 0 .1 0 .2 0c4.4 0 8 3.6 8 8s-4.4 8-8 8z" fill="#8b949e" stroke="#8b949e" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/></g><motion.g initial="hidden" animate="visible" variants={{ visible: { transition: { staggerChildren: 0.3 } } }}>{[...Array(3)].map((_, i) => <motion.path key={i} variants={{ hidden: { y: -5, opacity: 0 }, visible: { y: 0, opacity: 1, transition: { repeat: Infinity, duration: 2, delay: i * 0.5 } } }} d={`M20 ${56+i*2} l-2 2 l2 2 l-2-2 l2-2 M32 ${56+i*2} l-2 2 l2 2 l-2-2 l2-2 M44 ${56+i*2} l-2 2 l2 2 l-2-2 l2-2`} fill="none" stroke="#c9d1d9" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>)}</motion.g></motion.svg>
        ),
        'foggy': (
            <motion.svg viewBox="0 0 64 64" className={className}><g><path d="M45 51H11c-6.1 0-11-4.9-11-11s4.9-11 11-11c.5 0 1 0 1.4.1C14.7 21.6 22.5 16 31.5 16c9.9 0 18 7.6 18.4 17.4.1 0 .1 0 .2 0c4.4 0 8 3.6 8 8s-4.4 8-8 8z" fill="#8b949e" stroke="#8b949e" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/></g><motion.g initial="hidden" animate="visible" variants={{ visible: { transition: { staggerChildren: 0.5 } } }}><motion.path variants={{ hidden: { x: -15, opacity: 0 }, visible: { x: 0, opacity: 1, transition: { repeat: Infinity, duration: 3, repeatType: "mirror" }}}} d="M12 56h40" fill="none" stroke="#c9d1d9" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3"/><motion.path variants={{ hidden: { x: 15, opacity: 0 }, visible: { x: 0, opacity: 1, transition: { repeat: Infinity, duration: 3.5, repeatType: "mirror", delay: 0.5 }}}} d="M16 61h32" fill="none" stroke="#c9d1d9" stroke-linecap="round" stroke-miterlimit="10" stroke-width="3"/></motion.g></motion.svg>
        ),
        'default': (
            <motion.svg initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} viewBox="0 0 64 64" className={className}><path d="M32 16.5c-9.9 0-18 7.6-18.4 17.4-.1 0-.1 0-.2 0-4.4 0-8 3.6-8 8s3.6 8 8 8h34c4.4 0 8-3.6 8-8s-3.6-8-8-8h-1.5c-1-8.5-8-15.4-16.9-15.4z" fill="#c9d1d9" stroke-width="2" stroke-linejoin="round" stroke-miterlimit="10"/></motion.svg>
        ),
    };
    const iconKey = iconName?.toLowerCase().replace(/[\s_]/g, '-') || 'default';
    return icons[iconKey] || icons['default'];
};

const WeatherWidget = ({ widgetId }) => {
    const [location, setLocation] = useLocalStorage('weather_location', 'New York City');
    const [units, setUnits] = useLocalStorage('weather_units', 'C');
    const [isEditing, setIsEditing] = useState(false);
    const [inputLocation, setInputLocation] = useState(location);
    const { isRefreshing, register, unregister } = useRefresh();

    const request = useMemo(() => ({
        contents: `Get the current weather for ${location}. Provide temperature in degrees ${units === 'C' ? 'Celsius' : 'Fahrenheit'}.`,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    location: { type: Type.STRING },
                    temperature: { type: Type.NUMBER },
                    condition: { type: Type.STRING },
                    icon: { type: Type.STRING, description: "A single descriptive word like 'sunny', 'cloudy', 'rain', 'snow', 'thunderstorm', 'foggy', 'partly-cloudy'" },
                    feelsLike: { type: Type.NUMBER },
                    humidity: { type: Type.NUMBER, description: "Percentage value" },
                    windSpeed: { type: Type.NUMBER },
                    windUnit: { type: Type.STRING, description: "e.g., 'km/h' or 'mph'" }
                }
            }
        }
    }), [location, units]);
    
    const { data, isLoading, error, fetchData } = useGemini(request, { initialDelay: 250 });

    useEffect(() => {
        register(widgetId, fetchData);
        return () => unregister(widgetId);
    }, [widgetId, fetchData, register, unregister]);

    const weatherData = useMemo(() => {
        if (!data?.text) return null;
        try {
            return JSON.parse(data.text);
        } catch (e) {
            console.error("Failed to parse weather data:", e);
            // Don't set a permanent error, let retry handle it
            return null;
        }
    }, [data]);
    
    const handleSave = (e) => {
        e.preventDefault();
        if (inputLocation.trim()) {
            setLocation(inputLocation.trim());
            setIsEditing(false);
        }
    };

    const toggleUnits = useCallback(() => {
        setUnits(prev => (prev === 'C' ? 'F' : 'C'));
    }, [setUnits]);

    const weatherSummary = weatherData ? `The weather in ${weatherData.location} is currently ${weatherData.temperature} degrees ${units === 'C' ? 'Celsius' : 'Fahrenheit'} and ${weatherData.condition}.` : "Loading weather information.";

    return (
        <AnimatedCard isRefreshing={isRefreshing}>
             <WidgetHeader
                title={isEditing ? 'Settings' : 'Current Weather'}
                icon={<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>}
             >
                {!isEditing && <TextToSpeechButton textToSpeak={weatherSummary} playAriaLabel="Read weather summary" />}
                <motion.button whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} onClick={() => setIsEditing(!isEditing)} className="widget-settings-btn" aria-label="Weather settings">
                    <AnimatePresence mode="wait" initial={false}>
                        <motion.div key={isEditing ? 'close' : 'settings'} initial={{ opacity: 0, rotate: -90 }} animate={{ opacity: 1, rotate: 0 }} exit={{ opacity: 0, rotate: 90 }} transition={{ duration: 0.2 }}>
                            {isEditing ?
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> :
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                            }
                        </motion.div>
                    </AnimatePresence>
                </motion.button>
             </WidgetHeader>
             <div className="flex-grow flex flex-col justify-center items-center">
                <AnimatePresence mode="wait">
                    {isLoading && !weatherData ? (
                        <motion.div key="skeleton" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                            <WidgetSkeleton type="weather" />
                        </motion.div>
                    ) : error ? (
                         <motion.div key="error" variants={weatherContentVariants} initial="hidden" animate="visible" exit="exit">
                           <ErrorDisplay message={error} onRetry={fetchData} />
                        </motion.div>
                    ) : isEditing ? (
                        <motion.form key="editing" onSubmit={handleSave} variants={weatherContentVariants} initial="hidden" animate="visible" exit="exit" className="w-full flex flex-col gap-4">
                            <label htmlFor="location-input" className="font-semibold text-[var(--text-secondary)]">Location</label>
                            <input
                                id="location-input"
                                type="text"
                                value={inputLocation}
                                onChange={(e) => setInputLocation(e.target.value)}
                                className="form-input"
                                placeholder="e.g., London, UK"
                                autoFocus
                            />
                            <button type="submit" className="btn btn-primary">Save</button>
                        </motion.form>
                    ) : weatherData ? (
                        <motion.div key="content" variants={weatherContentVariants} initial="hidden" animate="visible" exit="exit" className="flex flex-col items-center text-center">
                            <div className="w-24 h-24 md:w-32 md:h-32 -mt-4">
                                <WeatherIcon iconName={weatherData.icon} />
                            </div>
                            <p className="font-black text-5xl md:text-6xl text-[var(--text-primary)] tracking-tighter -mt-2">
                                {Math.round(weatherData.temperature)}°
                                <button onClick={toggleUnits} className="text-2xl md:text-3xl text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors pl-1">
                                    <span className={units === 'C' ? 'text-[var(--text-primary)]' : ''}>C</span>
                                    <span className="text-[var(--border-color)]">/</span>
                                    <span className={units === 'F' ? 'text-[var(--text-primary)]' : ''}>F</span>
                                </button>
                            </p>
                             <p className="font-bold text-lg text-[var(--accent-primary)] capitalize">{weatherData.condition}</p>
                            <p className="text-[var(--text-secondary)] mt-1">{weatherData.location}</p>
                            <div className="flex gap-4 text-sm text-[var(--text-secondary)] mt-4 pt-4 border-t border-[var(--border-color)] w-full justify-center">
                                <span>Feels like {Math.round(weatherData.feelsLike)}°</span>
                                <span>Humidity {weatherData.humidity}%</span>
                                <span>Wind {weatherData.windSpeed}{weatherData.windUnit}</span>
                            </div>
                        </motion.div>
                    ) : (
                        <motion.div key="nodata" variants={weatherContentVariants} initial="hidden" animate="visible" exit="exit">
                           <p className="text-[var(--text-secondary)]">Could not load weather data.</p>
                        </motion.div>
                    )}
                </AnimatePresence>
             </div>
        </AnimatedCard>
    );
};


// --- APP STRUCTURE ---

const Widget = (props) => {
    switch (props.component) {
        case 'NewsWidget': return <NewsWidget {...props} />;
        case 'WeatherWidget': return <WeatherWidget {...props} />;
        case 'MarketWidget': return <MarketWidget {...props} />;
        case 'EventsWidget': return <EventsWidget {...props} />;
        case 'JokeWidget': return <JokeWidget {...props} />;
        default: return <AnimatedCard>Unknown Widget</AnimatedCard>;
    }
};

const Dashboard = () => {
    const initialWidgets = useMemo(() => [
        { id: 'news', component: 'NewsWidget' },
        { id: 'weather', component: 'WeatherWidget' },
        { id: 'market', component: 'MarketWidget' },
        { id: 'events', component: 'EventsWidget' },
        { id: 'joke', component: 'JokeWidget' },
    ], []);

    const [items, setItems] = useLocalStorage('dashboard_widgets_order_v3', [
        'news',
        'weather',
        'market',
        'events',
        'joke'
    ]);

    const widgets = useMemo(() => {
        const widgetMap = new Map(initialWidgets.map(w => [w.id, w]));
        return items.map(id => widgetMap.get(id)).filter(Boolean);
    }, [items, initialWidgets]);


    return (
        <Reorder.Group
            as="div"
            axis="y"
            values={items}
            onReorder={setItems}
            className="dashboard-grid"
            layoutScroll
        >
            {widgets.map(widget => (
                <Reorder.Item key={widget.id} value={widget.id}>
                    <Widget widgetId={widget.id} component={widget.component} />
                </Reorder.Item>
            ))}
        </Reorder.Group>
    );
};

const App = () => {
    return (
        <div className="app-container">
            <main className="content-wrapper p-4 md:p-8 max-w-7xl mx-auto">
                <Header />
                <Dashboard />
            </main>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <React.StrictMode>
        <ThemeProvider>
            <RefreshProvider>
                <App />
            </RefreshProvider>
        </ThemeProvider>
    </React.StrictMode>
);
